{"data":{"markdownRemark":{"html":"<p>Перевод Главы 2 книги Кайла Симпсона \"Вы не знаете JS. Типы данных и грамматика\".\nЭтот перевод можно также читать на <a href=\"https://github.com/azat-io/you-dont-know-js-ru\">{% assign image = page.images[1] %}{% include image.html image=image %}</a>. </p>\n<p><code>array</code>, <code>string</code>, и <code>number</code> являются основными составными элементами любой программы, но в JavaScript, при работе с этими типами данных, есть несколько особенностей, которые могут смутить или запутать вас.</p>\n<p>Давайте посмотрим на несколько встроенных типов JS, и разберемся как мы можем полностью понять и корректно использовать их поведение.</p>\n<h2>Массивы</h2>\n<p>Если сравнивать с другими строго-типизированными языками, в JavaScript массивы - всего  лишь контейнеры для любых типов значений, начиная от  <code>string</code> до <code>number</code> , <code>object</code> и даже других <code>array</code> (с помощью которых можно создавать многомерные массивы).</p>\n<pre><code class=\"language-js\">var a = [ 1, \"2\", [3] ];\n\na.length;       // 3\na[0] === 1;     // true\na[2][0] === 3;  // true\n</code></pre>\n<p>Вам не нужно предварительно устанавливать размер <code>array</code> (подробнее в \"Массивы\" Глава 3), вы можете просто объявить их и добавлять значения когда вам нужно:</p>\n<pre><code class=\"language-js\">var a = [ ];\n\na.length;   // 0\n\na[0] = 1;\na[1] = \"2\";\na[2] = [ 3 ];\n\na.length;   // 3\n</code></pre>\n<p><strong>Предупреждение:</strong> Используя <code>delete</code> для значения <code>array</code> будет удалена ячейка <code>array</code> с этим значением, но даже если вы удалите последний элемент таким способом, это <strong>НЕ</strong> обновит свойство <code>length</code> , так что будьте осторожны! Работа оператора <code>delete</code> более детально будет рассмотрена в Главе 5.</p>\n<p>Будьте осторожны при создании \"разрозненных\" массивов (оставляя или создавая пустые/пропущенные ячейки):</p>\n<pre><code class=\"language-js\">var a = [ ];\n\na[0] = 1;\n// ячейка `a[1]` отсутствует\na[2] = [ 3 ];\n\na[1];       // undefined\n\na.length;   // 3\n</code></pre>\n<p>Такой код может привести к странному поведению \"пустых ячеек\" оставленных между элементами массива. Пустой слот со значением <code>undefined</code> внутри, ведет себя не так же как явно объявленный эдемент массива (<code>a[1] = undefined</code>). Подробнее в главе 3 \"Массивы\".</p>\n<p>Массивы <code>array</code>s проиндексированы числами (как и ожидается), но хитрость в том, что они могут иметь индекс в виде  строки <code>string</code> ключ/свойство могут быть добавлены к массиву (но такие свойства не будут посчитаны в длине массива <code>length</code>):</p>\n<pre><code class=\"language-js\">var a = [ ];\n\na[0] = 1;\na[\"foobar\"] = 2;\n\na.length;       // 1\na[\"foobar\"];    // 2\na.foobar;       // 2\n</code></pre>\n<p>Как бы там ни было, нужно быть осторожнее при использовании индексов массива в виде <code>string</code> , т.к. это значение может быть преобразовано в тип <code>number</code>, потому что использование индекса <code>number</code> для массива предпочтительнее чем <code>string</code>!</p>\n<pre><code class=\"language-js\">var a = [ ];\n\na[\"13\"] = 42;\n\na.length; // 14\n</code></pre>\n<p>В общем, это не самая лучшая идея использовать пару <code>string</code> ключ/свойство как элемент массива <code>array</code>. Используйте <code>object</code> для хранения пар ключ/свойство, а массивы <code>array</code>s приберегите для хранения значений в ячейках с числовыми индексами.</p>\n<h3>Массивоподобные</h3>\n<p>Бывают случаи когда нужно преобразовать  массивоподобное значение (пронумерованную коллекцию значений) в настоящий массив <code>array</code>, обычно таким образом вы сможете применить методы массива (такие как <code>indexOf(..)</code>, <code>concat(..)</code>, <code>forEach(..)</code>, etc.) к коллекции значений.</p>\n<p>Например, различные DOM запросы возвращают список DOM элементов который не является настоящим массивом <code>array</code>, но, при этом он достаточно похож на массив для преобразования. Другой общеизвестный пример - когда функция предоставляет свои аргументы <code>arguments</code> в виде массивоподобного объекта (в ES6, считается устаревшим), чтобы получить доступ к списку аргументов.</p>\n<p>Один из самых распространенных способов осуществить такое преобразование одолжить метод <code>slice(..)</code> для значения:</p>\n<pre><code class=\"language-js\">function foo() {\n    var arr = Array.prototype.slice.call( arguments );\n    arr.push( \"bam\" );\n    console.log( arr );\n}\n\nfoo( \"bar\", \"baz\" ); // [\"bar\",\"baz\",\"bam\"]\n</code></pre>\n<p>Если <code>slice()</code> вызван без каких-либо параметров, как в примере выше, стандартные значения его параметров позволят продублировать массив <code>array</code> (а в нашем случае , массивоподобное значение).</p>\n<p>В ES6, есть встроенный метод <code>Array.from(..)</code> который при вызове выполнит то же самое:</p>\n<pre><code class=\"language-js\">...\nvar arr = Array.from( arguments );\n...\n</code></pre>\n<p><strong>Примечание:</strong> <code>Array.from(..)</code> имеет несколько мощных возможностей, детально о них рассказано в книге <em>ES6 и не только</em> данной серии.</p>\n<h2>Строки</h2>\n<p>Есть общее мнение, что строки <code>string</code> являются всего лишь массивами <code>array</code> из символов. Пока мы решаем можно или нельзя использовать <code>array</code>, важно осознавать что JavaScript <code>string</code>на самом деле не то же самое что массивы <code>array</code> символов. Это сходство по большей части поверхностное.</p>\n<p>Например, давайте сравним два значения:</p>\n<pre><code class=\"language-js\">var a = \"foo\";\nvar b = [\"f\",\"o\",\"o\"];\n</code></pre>\n<p>Строки имеют поверхностные сходства по отношению к массивам и массивоподобным, такие как -- например, оба из них имеют свойство <code>length</code>,метод <code>indexOf(..)</code> (<code>array</code> только в ES5), и метод <code>concat(..)</code>:</p>\n<pre><code class=\"language-js\">a.length;                           // 3\nb.length;                           // 3\n\na.indexOf( \"o\" );                   // 1\nb.indexOf( \"o\" );                   // 1\n\nvar c = a.concat( \"bar\" );          // \"foobar\"\nvar d = b.concat( [\"b\",\"a\",\"r\"] );  // [\"f\",\"o\",\"o\",\"b\",\"a\",\"r\"]\n\na === c;                            // false\nb === d;                            // false\n\na;                                  // \"foo\"\nb;                                  // [\"f\",\"o\",\"o\"]\n</code></pre>\n<p>Итак строки по большей части это \"массивы символов\", верно? <strong>НЕ совсем</strong>:</p>\n<pre><code class=\"language-js\">a[1] = \"O\";\nb[1] = \"O\";\n\na; // \"foo\"\nb; // [\"f\",\"O\",\"o\"]\n</code></pre>\n<p>В JavaScript строки <code>string</code> неизменяемы, тогда как массивы <code>array</code> достаточно изменяемы. Более того форма доступа к символу строки вида <code>a[1]</code>  не совсем правильный JavaScript. Старые версии IE не разрешают такой синтаксис (в новых версиях IE это работает). Вместо него нужно использовать <em>корректный</em> способ -  <code>a.charAt(1)</code>.</p>\n<p>Еще одним подследствием неизменяемости строк <code>string</code> является то что ни один метод строки <code>string</code> меняющий ее содержимое не может делать это по месту, скорее метод создаст и вернет новые строки. И напротив, большинство методов изменяющих содержимое массива <code>array</code> действительно <em>делают</em> изменения по месту.</p>\n<pre><code class=\"language-js\">c = a.toUpperCase();\na === c;    // false\na;          // \"foo\"\nc;          // \"FOO\"\n\nb.push( \"!\" );\nb;          // [\"f\",\"O\",\"o\",\"!\"]\n</code></pre>\n<p>Также многие из методов массива <code>array</code>, которые могут быть полезны при работе со строками <code>string</code> вообще для них недоступны, но мы можем \"одолжить\" неизменяющие методы массива <code>array</code> для нашей строки <code>string</code>:</p>\n<pre><code class=\"language-js\">a.join;         // undefined\na.map;          // undefined\n\nvar c = Array.prototype.join.call( a, \"-\" );\nvar d = Array.prototype.map.call( a, function(v){\n    return v.toUpperCase() + \".\";\n} ).join( \"\" );\n\nc;              // \"f-o-o\"\nd;              // \"F.O.O.\"\n</code></pre>\n<p>Давайте возьмем другой пример: реверсируем строку <code>string</code> (кстати, это довольно тривиальный общий вопрос на  JavaScript собеседованиях!). У массивов <code>array</code>есть метод <code>reverse()</code> осуществляюший изменение по месту, но для строки <code>string</code>такого метода нет:</p>\n<pre><code class=\"language-js\">a.reverse;      // undefined\n\nb.reverse();    // [\"!\",\"o\",\"O\",\"f\"]\nb;              // [\"!\",\"o\",\"O\",\"f\"]\n</code></pre>\n<p>К несчастью, это \"одалживание\" не сработает с методами изменяющими массив <code>array</code>, потому что строки <code>string</code> неизменяемы и поэтому не могут быть изменены по месту:</p>\n<pre><code class=\"language-js\">Array.prototype.reverse.call( a );\n// все еще возвращаем объект-обертку String (подробнее в Главе 3)\n// для \"foo\" :(\n</code></pre>\n<p>Другое временное решение (хак) отконвертировать строку <code>string</code> в массив <code>array</code>, выполнить желаемое действие, и затем отконвертировать обратно в строку <code>string</code>.</p>\n<pre><code class=\"language-js\">var c = a\n    // разбиваем `a` на массив символов\n    .split( \"\" )\n    // реверсируем массив символов\n    .reverse()\n    // объединяем массив символов обратно в строку\n    .join( \"\" );\n\nc; // \"oof\"\n</code></pre>\n<p>Если кажется, что это выглядит безобразно, так и есть. Тем не менее, <em>это работает</em> для простых строк <code>string</code>, так что, если вам нужно \"склепать\" что-нибудь по быстрому, часто такой подход позволит выполнить работу.</p>\n<p><strong>Предупреждение:</strong> Будьте осторожны! Этот подход <strong>не работает</strong> для строк <code>string</code> со сложными (unicode) символами в них (astral symbols, multibyte characters, etc.). Вам потребуются более сложные библиотеки которые распознают unicode символы для правильного выполнения подобных операций. Подробнее можно посмотреть в работе Mathias Bynens': <em>Esrever</em> (<a href=\"https://github.com/mathiasbynens/esrever\">https://github.com/mathiasbynens/esrever</a>).</p>\n<p>Хотя с другой стороны: если вы чаще работаете с вашими \"строками\",  интерпритируя их как <em>массивы символов</em>, возможно лучше просто записывать их в массив <code>array</code>вместо строк <code>string</code>.Возможно вы избавите себя от хлопот при переводе строки <code>string</code> в массив <code>array</code>каждый раз. Вы всегда можете вызвать <code>join(\"\")</code> для массива <code>array</code> <em>символов</em> когда вам понадобится представление в ивде строки <code>string</code>.</p>\n<h2>Числа</h2>\n<p>В JavaScript есть один числовой тип: <code>number</code>. Этот тип включает в себя как \"целые\" (\"integer\") значения так и десятичные дробные числа. Я заключил \"целые\" (\"integer\") в кавычки, потому что в JS это понятие подвергается критике, поскольку здесь нет реально целых значений, как в других языках программирования. Возможно в будущем это изменится, но сейчас, у нас просто есть тип <code>number</code>для всего.</p>\n<p>Итак, в JS, \"целое\" (\"integer\") это просто числовое значение, которое не имеет десятичной составляющей после запятой . Так нпаример, <code>42.0</code> более может считаться \"целым\"(\"integer\"), чем <code>42</code>.</p>\n<p>Как и в большинстве современных языков, включая практически все скриптовые языки, реализация чисел <code>number</code> в JavaScript'основана на стандарте \"IEEE 754\", котороый часто называют \"числа с плавающей точкой\" (\"floating-point\"). JavaScript особенно использует формат \"двойной степени точности\" (как \"64-битные в бинарном формате\") этого стандарта.</p>\n<p>В интернете есть множество статей о подробных деталях того, как бинарные числа с плавющей точкой записываются в память, и последствия выбора таких чисел. Т.к. понимание того как работает запись в память не строго необходимо для того чтобы корректно использовать числа <code>number</code> в JS, мы оставим это упражнение для заинтересованного читателя, если вы захотите более детально разобраться со стандартом IEEE 754.</p>\n<h3>Числовой синтаксис</h3>\n<p>Чичловые литералы в JavaScript в большинстве представлены как литералы десятичных дробей. Например:</p>\n<pre><code class=\"language-js\">var a = 42;\nvar b = 42.3;\n</code></pre>\n<p>Если целая часть дробного числа - <code>0</code>, можно ее опустить:</p>\n<pre><code class=\"language-js\">var a = 0.42;\nvar b = .42;\n</code></pre>\n<p>Аналогично, если дробная часть после точки <code>.</code>, - <code>0</code>, можно ее опустить:</p>\n<pre><code class=\"language-js\">var a = 42.0;\nvar b = 42.;\n</code></pre>\n<p><strong>Предупреждение:</strong> <code>42.</code> выглядит достаточно необычно, и возможно это не лучшая идея если вы хотите избежать недопонимания со стороны других людей при работе с вашим кодом. Но, в любом случае, это корректная запись.</p>\n<p>По умолчанию, большинство чисел <code>number</code> выводятся как десятичные дроби, с удаленными нулями <code>0</code> в конце дробной части. Так:</p>\n<pre><code class=\"language-js\">var a = 42.300;\nvar b = 42.0;\n\na; // 42.3\nb; // 42\n</code></pre>\n<p>Очень большие или очень маленькие числа <code>number</code> по умолчанию выводятся в экспоненциальной форме, также как и результат метода <code>toExponential()</code>, например:</p>\n<pre><code class=\"language-js\">var a = 5E10;\na;                  // 50000000000\na.toExponential();  // \"5e+10\"\n\nvar b = a * a;\nb;                  // 2.5e+21\n\nvar c = 1 / a;\nc;                  // 2e-11\n</code></pre>\n<p>Т.к. числовые значения <code>number</code> могут быть помещены в объект - обертку <code>Number</code> (подробнее Глава 3), числовые значения <code>number</code> могут получать методы встроенные в <code>Number.prototype</code> (подробнее Глава 3). Например, метод <code>toFixed(..)</code> позволяет вам определить с точностью до скольки знаков после запятой вывести дробную часть:</p>\n<pre><code class=\"language-js\">var a = 42.59;\n\na.toFixed( 0 ); // \"43\"\na.toFixed( 1 ); // \"42.6\"\na.toFixed( 2 ); // \"42.59\"\na.toFixed( 3 ); // \"42.590\"\na.toFixed( 4 ); // \"42.5900\"\n</code></pre>\n<p>Заметьте что результат - строковлое <code>string</code> представление числа <code>number</code>, и таким образом <code>0</code>- будет добавлено справа если вам понадобится больше знаков после запятой, чем есть сейчас.</p>\n<p><code>toPrecision(..)</code> похожий метод, но он определяет сколько <em>цифровых знаков</em> должно использоваться в выводимом значении:</p>\n<pre><code class=\"language-js\">var a = 42.59;\n\na.toPrecision( 1 ); // \"4e+1\"\na.toPrecision( 2 ); // \"43\"\na.toPrecision( 3 ); // \"42.6\"\na.toPrecision( 4 ); // \"42.59\"\na.toPrecision( 5 ); // \"42.590\"\na.toPrecision( 6 ); // \"42.5900\"\n</code></pre>\n<p>Вам не обязательно использовать переменные для хранения чисел, чтобы применить эти методы; вы можете применять методы прямо к числовым литералам <code>number</code>. Но, будьте осторожны с оператором <code>.</code>. Т.к. <code>.</code> это еще и числовой оператор, и, если есть такая  возможность, он в первую очередь будет интепритирован как часть числового литерала <code>number</code>, вместо того чтобы получать доступ к свойству.</p>\n<pre><code class=\"language-js\">// неправильный ситнтакс:\n42.toFixed( 3 );    // SyntaxError\n\n// это корректное обращение к методам:\n(42).toFixed( 3 );  // \"42.000\"\n0.42.toFixed( 3 );  // \"0.420\"\n42..toFixed( 3 );   // \"42.000\"\n</code></pre>\n<p><code>42.toFixed(3)</code> неверный синтакс, потому что <code>.</code> станет частью числового литерала <code>42.</code> (такая запись корректна -- смотрите выше!), и тогда оператор <code>.</code> который должен получить доступ к методу <code>.toFixed</code> отсутствует.</p>\n<p><code>42..toFixed(3)</code> работает т.к. первый оператор <code>.</code> часть чилового литерала <code>number</code> второая <code>.</code> оператор доступа к свойству. Но, возможно это выглядит странно, и на самом деле очень редко можно увидеть что-то подобное в реальном JavaScript коде. Фактически, это нестандартно -- применять методы прямо к примитивным значениям. Нестандартно не значит <em>плохо</em> или <em>неправильно</em>.</p>\n<p><strong>Примечание:</strong> Есть библиотеки расширяющие встроенные методы <code>Number.prototype</code> (подробнее Глава 3) для поддержки операций над/с числами <code>number</code>, и в этих случаях, совершенно правильно использовать <code>10..makeItRain()</code> чтобы отключить 10-секундную анимацию денежного дождя, или еще что-нибудь такое же глупое.</p>\n<p>Также технически корректной будет такая запись (заметьте пробел):</p>\n<pre><code class=\"language-js\">42 .toFixed(3); // \"42.000\"\n</code></pre>\n<p>Тем не менее, с числовыми литералами <code>number</code> особенно, <strong>это черезвычайно запутанный стиль кода</strong> и он не преследует иных цедей кроме как запутать разработчиков при работе с кодом (в том числе и вас в будущем). Избегайте этого.</p>\n<p>Числа <code>number</code> также могут быть представлены в экспоненциальной форме, которую обычно используют для представления больших чисел <code>number</code> таких как:</p>\n<pre><code class=\"language-js\">var onethousand = 1E3;                      // means 1 * 10^3\nvar onemilliononehundredthousand = 1.1E6;   // means 1.1 * 10^6\n</code></pre>\n<p>Числовые литералы <code>number</code> могут быть также выражены в других формах, таких как, двоичная, восьмеричная, и шестнадцатиричная.</p>\n<p>Эти форматы работают в текущей версии JavaScript:</p>\n<pre><code class=\"language-js\">0xf3; // шестнадцатиричная для: 243\n0Xf3; // то же самое\n\n0363; // восьмеричная для: 243\n</code></pre>\n<p><strong>Примечание:</strong> Начиная с ES6 с включенным <code>strict</code> режимом, восьмеричная форма <code>0363</code> больше не разрешена (смотрите ниже новую форму). Форма <code>0363</code> все еще разрешена в <code>non-strict</code> режиме, но в любом случае нужно прекратить ее использовать, чтобы использовать современный подход (и потому что пора бы использовать <code>strict</code> режим уже сейчас!).</p>\n<p>Для ES6, доступны новые формы записи:</p>\n<pre><code class=\"language-js\">0o363;      // восьмеричная для: 243\n0O363;      // то же самое\n\n0b11110011; // двоичная для: 243\n0B11110011; // то же самое\n</code></pre>\n<p>И пожалуйста окажите вашим коллегам - разработчикам услугу: никогда не используйте форму вида <code>0O363</code>. <code>0</code> перед заглавной <code>O</code> может лишь вызвать затруднение при чтении кода. Всегда используйте нижний регистр в подобных формах: <code>0x</code>, <code>0b</code>, и <code>0o</code>.</p>\n<h3>Маленькие дробные числа</h3>\n<p>Самый известный побочный эффект от использования бинарной формы чисел с плавающей точкой (которая, как мы помним, справедлива для <strong>всех</strong> языков использующих стандарт IEEE 754 -- не <em>только</em> JavaScript как многие привыкли предполагать) это:</p>\n<pre><code class=\"language-js\">0.1 + 0.2 === 0.3; // false\n</code></pre>\n<p>Математически, что результатом выражения должно быть <code>true</code>. Почему же в результате получается <code>false</code>?</p>\n<p>Если по простому, представления чисел <code>0.1</code> и <code>0.2</code> в бинарном виде с плавающей точкой не совсем точные, поэтому когда мы их складываем, результат не совсем <code>0.3</code>. Это <strong>действительно</strong> близко: <code>0.30000000000000004</code>, но если сравнение не прошло, \"близко\" уже не имеет значения.</p>\n<p><strong>Примечание:</strong> Должен ли JavaScript перейти на другую реализацию числового типа <code>number</code> которая имеет точные представления для всех значений? Некоторые так думают. За все годы появлялось много альтернатив. Никакие из них до сих пор не были утверждены, и возможно никогда не будут. Кажется что это также легко, как просто поднять руку и сказать \"Да исправьте вы уже этот баг!\", но это вовсе не так. Если бы это было легко, это определенно было бы имправлено намного раньше.</p>\n<p>Сейчас, вопрос в том, что если есть числа <code>number</code> для которых нельзя быть <em>уверенным</em> в их точности, может нам совсем не стоит испльзовать числа <code>number</code>? <strong>Конечно нет.</strong></p>\n<p>Есть несколько случаев применения чисел, где нужно быть осторожными, особенно имея дело с дробными числами. Также есть достаточно (возможно большинство?) случаев когда мы имеем дело только с целыми числами (\"integers\"), и более того, работаем только с числами максимум до миллиона или триллиона. Такие случаи применения чисел всегда были, и будут, <strong>превосходно безопасными</strong> для проведения числовых операций в JS.</p>\n<p>Ео что если нам <em>было</em> нужно сравнить два числа <code>number</code> таких как <code>0.1 + 0.2</code> и <code>0.3</code>, зная что обычный тест на равенство не сработает?</p>\n<p>Самая общепринятая практикаиспользование миниатюрной \"ошибки округления\" как <em>допуска</em> для сравнения. Это малюсенькое значение часто называют \"машинной эпсилон,\" которое составляет <code>2^-52</code> (<code>2.220446049250313e-16</code>) для числового типа <code>number</code> в JavaScript.</p>\n<p>В ES6, <code>Number.EPSILON</code> определено заранее этим пороговым значением, так что если вы хотите его использовать, нужно применить полифилл для определения порогового значения для стандартов до-ES6:</p>\n<pre><code class=\"language-js\">if (!Number.EPSILON) {\n    Number.EPSILON = Math.pow(2,-52);\n}\n</code></pre>\n<p>Мы можем использовать это значение <code>Number.EPSILON</code> для проверки двух чисел <code>number</code>на \"равенство\" (с учетом допуска ошибки округления):</p>\n<pre><code class=\"language-js\">function numbersCloseEnoughToEqual(n1,n2) {\n    return Math.abs( n1 - n2 ) &#x3C; Number.EPSILON;\n}\n\nvar a = 0.1 + 0.2;\nvar b = 0.3;\n\nnumbersCloseEnoughToEqual( a, b );                  // true\nnumbersCloseEnoughToEqual( 0.0000001, 0.0000002 );  // false\n</code></pre>\n<p>Максимальное значение числа с плавающей точкой приблизительно <code>1.798e+308</code> (реально огромное число!), определено как <code>Number.MAX_VALUE</code>. Минимальное значение, <code>Number.MIN_VALUE</code> приблизительно <code>5e-324</code>, оно положительное, но очень близко к нулю!</p>\n<h3>Безопасные диапазоны целых чисел</h3>\n<p>Из-за представления чисел <code>number</code>в JS, существует диапазон \"безопасных\" значений для всех чисел <code>number</code> \"integers\", и он существенно меньше значения <code>Number.MAX_VALUE</code>.</p>\n<p>Максимальное целое число, которое может быть \"безопасно\" представлено (это означает гарантию того, что запрашиваемое значение будет представлено совершенно определенно) это <code>2^53 - 1</code>, что составляет <code>9007199254740991</code>. Если вы добавите запятые, то увидите что это немного больше 9 квадридллионов. Так что это чертовски много для верхнего диапазона чисел <code>number</code>.</p>\n<p>Это значение автоматически предопределенно в ES6, как <code>Number.MAX_SAFE_INTEGER</code>. Ожидаемо, минимальное значение, <code>-9007199254740991</code>, соответственно предопрелено в ES6 как <code>Number.MIN_SAFE_INTEGER</code>.</p>\n<p>Чаще всего JS программы могут столкнуться с такими большими чилами, когда имеют дело с 64-битными ID баз данных, и т.п.. 64-битные не могут быть точно представлены типом <code>number</code>, так что они должны быть записаны (и переданы в/из) JavaScript с помощью строкового <code>string</code> представления.</p>\n<p>Математические операции с ID <code>number</code> значениями (кроме сравнения, которое отлично пройдет со строками <code>string</code>) обычно не выполняются, к счастью. Но если вам <em>необходимо</em> выполнить математическую операцию с очень большими числами, сейчас вы можете использовать утилиту <em>big number</em>. Поддержка больших чисел может быть реализована в будущих стандартах JavaScript.</p>\n<h3>Проверяем является ли число целым</h3>\n<p>Чтобы проверить,является ли число целым, вы можете использовать специальный ES6-метод <code>Number.isInteger(..)</code>:</p>\n<pre><code class=\"language-js\">Number.isInteger( 42 );     // true\nNumber.isInteger( 42.000 ); // true\nNumber.isInteger( 42.3 );   // false\n</code></pre>\n<p>Полифилл для <code>Number.isInteger(..)</code> для стандартов до-ES6:</p>\n<pre><code class=\"language-js\">if (!Number.isInteger) {\n    Number.isInteger = function(num) {\n        return typeof num == \"number\" &#x26;&#x26; num % 1 == 0;\n    };\n}\n</code></pre>\n<p>Для проверки на нахождение числа в безопасном диапазоне <em>safe integer</em>, используется ES6-метод  <code>Number.isSafeInteger(..)</code>:</p>\n<pre><code class=\"language-js\">Number.isSafeInteger( Number.MAX_SAFE_INTEGER );    // true\nNumber.isSafeInteger( Math.pow( 2, 53 ) );          // false\nNumber.isSafeInteger( Math.pow( 2, 53 ) - 1 );      // true\n</code></pre>\n<p>Полифилл для <code>Number.isSafeInteger(..)</code> для стандартов до-ES6:</p>\n<pre><code class=\"language-js\">if (!Number.isSafeInteger) {\n    Number.isSafeInteger = function(num) {\n        return Number.isInteger( num ) &#x26;&#x26;\n            Math.abs( num ) &#x3C;= Number.MAX_SAFE_INTEGER;\n    };\n}\n</code></pre>\n<h3>32-битные целые числа (со знаком)</h3>\n<p>Пока целые числа могут быть приблизительно до 9 квадриллионов (53 бита), есть несколько числовых операторов (например побитовые операторы), которые определены для 32-битных чисел <code>number</code>, так \"безопасный диапазон\" для чисел <code>number</code> используемый в таких случаях намного меньше.</p>\n<p>Диапазоном является от <code>Math.pow(-2,31)</code> (<code>-2147483648</code>, около -2.1 милллиардов) до <code>Math.pow(2,31)-1</code> (<code>2147483647</code>, около +2.1 миллиардов).</p>\n<p>Чтобы записать число <code>number</code> из переменной <code>a</code> в 32-битное целое число, используем <code>a | 0</code>. Это сработает т.к.  <code>|</code> побитовый оператор и работает только с 32-битными целыми числами (это означает что он будет работать только с 32 битами, а остальные биты будут утеряны). Ну, а \"ИЛИ\" с нулем побитовый оператор, который не проводит операций с битами.</p>\n<p><strong>Примечание:</strong> Определенные специальные значения (о которых будет расказано далее) такие как <code>NaN</code> и  <code>Infinity</code> не являются \"32-битными безопасными значениями\" и в случае передачи этих значений побитовому оператору, будет применен абстрактный оператор  <code>ToInt32</code> (смотрите главу 4) результатом которого будет значение<code>+0</code> для последующего применения побитового оператора.</p>\n<h2>Специальные значения</h2>\n<p>Есть несколько специальных значений, которые распространяются на все типы, и с которыми <em>внимательный</em> JS разработчик должен быть осторожен, и использовать их по назначению.</p>\n<h3>Отстуствие значения</h3>\n<p>Для типа <code>undefined</code>, есть только одно значение: <code>undefined</code>. Для типа <code>null</code>, есть только одно значение: <code>null</code>. Итак для них обоих, есть свой тип и свое значение.</p>\n<p>И <code>undefined</code> и <code>null</code> часто считаются взаимозаменяемыми, как либо \"пустое\" значение, либо его \"отсутствие\". Другие разработчики различают их в соответствиис их особенностями. Например:</p>\n<ul>\n<li><code>null</code> пустое значение</li>\n<li><code>undefined</code> остуствующее значение</li>\n</ul>\n<p>Или:</p>\n<ul>\n<li><code>undefined</code> значение пока не присвоено</li>\n<li><code>null</code> значение есть и там ничего не содержится</li>\n</ul>\n<p>Независимо от того, как вы \"определяете\" и используете эти два значения, <code>null</code> это специальное ключевое слово, не является идентификатором, и таким образом нельзя его использовать для назначения переменной (зачем вообще это делать!?). Как бы там ни было, <code>undefined</code> <em>является</em> (к несчастью) идентификатором. Увы и ах.</p>\n<h3>Undefined</h3>\n<p>В нестрогом режиме non-<code>strict</code>, действительно есть возможность (хоть это и срезвчайно плохая идея!) присваивать значение глобальному идентификатору <code>undefined</code> :</p>\n<pre><code class=\"language-js\">function foo() {\n    undefined = 2; // очень плохая идея!\n}\n\nfoo();\n</code></pre>\n<pre><code class=\"language-js\">function foo() {\n    \"use strict\";\n    undefined = 2; // TypeError!\n}\n\nfoo();\n</code></pre>\n<p>Как в нестрогом non-<code>strict</code> так и в строгом <code>strict</code> режимах, тем не менее, вы можете создать локальную переменную <code>undefined</code>. Но, еше раз, это ужасная идея!</p>\n<pre><code class=\"language-js\">function foo() {\n    \"use strict\";\n    var undefined = 2;\n    console.log( undefined ); // 2\n}\n\nfoo();\n</code></pre>\n<p><strong>Настоящие друзья никогда не позволят друзьям переназначить <code>undefined</code>.</strong> Никогда.</p>\n<h4>Оператор <code>void</code></h4>\n<p>Пока <code>undefined</code> является встроенным идентификатором который содержит (если только кто-нибудь это не изменил -- см. выше!) встроенное значение <code>undefined</code>, другой способ получить это значение - оператор <code>void</code>.</p>\n<p>Выражение <code>void ___</code> \"аннулирует\" любое значение, так что результатом выражения всегда будет являться значение <code>undefined</code>. Это выражение не изменяет действующее значение; оно просто дает нам уверенность в том, что мы не получим назад другого значения после применения оператора.</p>\n<pre><code class=\"language-js\">var a = 42;\n\nconsole.log( void a, a ); // undefined 42\n</code></pre>\n<p>По соглашению (большей частью из C-языка прогаммирования), для получения только самого значения <code>undefined</code> вместо использования <code>void</code>, вы можете использовать <code>void 0</code> (хотя и понятно что даже <code>void true</code> или любое другое <code>void</code> выражение выполнит то же самое). На практике нет никакой разницы между <code>void 0</code>, <code>void 1</code>, и <code>undefined</code>.</p>\n<p>Но, оператор <code>void</code> может быть полезен в некоторых других обстоятельствах, например, если нужно быть уверенным, что выражение не вернет никакого результата (даже если оно имеет побочный эффект).</p>\n<p>Например:</p>\n<pre><code class=\"language-js\">function doSomething() {\n    // примечание: `APP.ready` поддерживается нашим приложением\n    if (!APP.ready) {\n        // попробуйте еще раз позже\n        return void setTimeout( doSomething, 100 );\n    }\n\n    var result;\n\n    // делаем что - нибудь другое\n    return result;\n}\n\n// есть возможность выполнить задачу прямо сейчас?\nif (doSomething()) {\n    // выполняем следующие задания немедленно right away\n}\n</code></pre>\n<p>Здесь, функция <code>setTimeout(..)</code> возвращает числовое значение (уникальный идентификатор интервала таймера, если вы захотите его отменить), но нам нужно применить оператор <code>void</code> чтобы значение, которое вернет функция не было  ложно-положительным  с инструкцией <code>if</code>.</p>\n<p>Многие разработчики  предпочитают выполнять действия по отдельности, что в результате работает так же, но не требует применения оператора <code>void</code>:</p>\n<pre><code class=\"language-js\">if (!APP.ready) {\n    // попробуйте еще раз позже\n    setTimeout( doSomething, 100 );\n    return;\n}\n</code></pre>\n<p>Итак, если есть место где существует значение (как результат выражения) , и вы находите полезным получить вместо него <code>undefined</code>, используйте оператор <code>void</code>. Возможно это не должно часто встречаться в ваших программах, но в редких случах, когда это понадобится, это может быть довольно полезным.</p>\n<h3>Специальные числа</h3>\n<p>Тип <code>number</code> включает в себя несколько специальных значений. Рассмотрим каждое более подробно.</p>\n<h4>НЕ Число, Число</h4>\n<p>Любая математическая операция которую выполняют с операндами не являющимися числами <code>number</code> (или значениями которые могут быть интерпритированы как числа <code>number</code>в десятчиной или шестнадцатиричной форме) приведет к ошибке при попытке получить значение чилового типа <code>number</code>, в этом случае вы получите значение <code>NaN</code>.</p>\n<p><code>NaN</code> буквально означает \"not a <code>number</code> (\"НЕ число\"), хотя это название/описание довольно скудное и обманчивое, как мы скоро увидим. Было бы правильнее думать о  <code>NaN</code> как о \"неправильном числе,\" \"ошибочном числе,\" или даже \"плохом числе,\" чем думать о нем как о  \"НЕ числе.\"</p>\n<p>Например:</p>\n<pre><code class=\"language-js\">var a = 2 / \"foo\";      // NaN\n\ntypeof a === \"number\";  // true\n</code></pre>\n<p>Другими словами: \"Типом НЕ-числа явдяется число 'number'!\" Ура запутывающим именам и семантике.</p>\n<p><code>NaN</code> навроде \"сторожевого значения\" (другими словами нормальное значение, которое несет специальный смысл) которое определяет сбой при проведении операции назначения числа <code>number</code>. Эта ошибка, по сути означает следующее: \"Я попробовал выполнить математическую операция и произошла ошибка, поэтому, вместо результата, здесь ошибочное число <code>number</code>.\"</p>\n<p>Итак, если у вас есть значение в какой-нибудь переменной, и вы хотите проверить, не является ли оно ошибочным числом <code>NaN</code>, вы должно быть думаете что можно просто его сравнить пямо с <code>NaN</code>, как с любым другим значением, например <code>null</code> или <code>undefined</code>. Неа.</p>\n<pre><code class=\"language-js\">var a = 2 / \"foo\";\n\na == NaN;   // false\na === NaN;  // false\n</code></pre>\n<p><code>NaN</code> очень особенное значение и оно никогда не будет равно другому значению <code>NaN</code> (т.е., оно не равно самому себе). Фактически, это всего лишь значение, которое не рефлексивно (без возможности идентификации <code>x === x</code>). Итак, <code>NaN !== NaN</code>. Немного странно, да?</p>\n<p>Так как мы <em>можем</em> его проверить, если нельзя сравнить с <code>NaN</code> (т.к. сравнение не сработает)?</p>\n<pre><code class=\"language-js\">var a = 2 / \"foo\";\n\nisNaN( a ); // true\n</code></pre>\n<p>Достаточно просто, верно? мы использовали встроенную глобальную функцию, которая называется <code>isNaN(..)</code> и она сообщила нам является значение <code>NaN</code> или нет. Проблема решена!</p>\n<p>Не так быстро.</p>\n<p>У функции <code>isNaN(..)</code> есть большой недостаток. Он появляется при попытках воспринимать значение <code>NaN</code> (\"НЕ-Число\") слишком буквально -- вот, вкратце, как это работает: \"проверяем то, что нам передали -- либо это не является числом <code>number</code>, либо -- это число <code>number</code>.\" Но это не совсем правильно.</p>\n<pre><code class=\"language-js\">var a = 2 / \"foo\";\nvar b = \"foo\";\n\na; // NaN\nb; // \"foo\"\n\nwindow.isNaN( a ); // true\nwindow.isNaN( b ); // true -- упс!\n</code></pre>\n<p>Понятно, <code>\"foo\"</code> буквально <em>НЕ-Число</em>, но и определенно не яляется значением <code>NaN</code>! Этот баг был в JS с самого начала (более 19 лет <em>упс</em>).</p>\n<p>В ES6, наконец была представлена функция: <code>Number.isNaN(..)</code>. Простым полифиллом, чтобы вы могли проверить на значение <code>NaN</code> <em>прямо сейчас</em>, даже в браузерах не поддерживающих-ES6, будет:</p>\n<pre><code class=\"language-js\">if (!Number.isNaN) {\n    Number.isNaN = function(n) {\n        return (\n            typeof n === \"number\" &#x26;&#x26;\n            window.isNaN( n )\n        );\n    };\n}\n\nvar a = 2 / \"foo\";\nvar b = \"foo\";\n\nNumber.isNaN( a ); // true\nNumber.isNaN( b ); // false -- фуух!\n</code></pre>\n<p>Вообще,  мы можем реализовать полифилл <code>Number.isNaN(..)</code> даже проще, если воспользоваться специфической особенностью <code>NaN</code>, которое не равно самому себе. <code>NaN</code> <em>единственное</em> для котрого это справедливо; любое другое значение всегда <strong>равно самому себе</strong>.</p>\n<p>Итак:</p>\n<pre><code class=\"language-js\">if (!Number.isNaN) {\n    Number.isNaN = function(n) {\n        return n !== n;\n    };\n}\n</code></pre>\n<p>Странно, правда? Но это работает!</p>\n<p><code>NaN</code>могут появляться во многих действующих JS программах, намеренно или случайно. Это действительно хорошая идея проводить надежную проверку, например <code>Number.isNaN(..)</code> если это поддерживается (или полифилл), чтобы распознать их должным образом.</p>\n<p>Если вы все еще используете <code>isNaN(..)</code> в своей программе, плохая новость: в вашей программе <em>есть баг</em>, даже если вы с ним еще не столкнулись!</p>\n<h4>Бесконечности</h4>\n<p>Разработчик пришедшие из традиционных компилируемых языков вроде C, возможно, привыкли видеть ошибку компилирования ли выполнения, например \"деление на ноль,\" для подобных операций:</p>\n<pre><code class=\"language-js\">var a = 1 / 0;\n</code></pre>\n<p>Как бы там ни было, в JS, эта операция четко определена, и ее результатом будет являться -- бесконечность <code>Infinity</code> (ну или <code>Number.POSITIVE_INFINITY</code>). Как и ожидается:</p>\n<pre><code class=\"language-js\">var a = 1 / 0;  // Infinity\nvar b = -1 / 0; // -Infinity\n</code></pre>\n<p>Как вы видите, <code>-Infinity</code> (или <code>Number.NEGATIVE_INFINITY</code>) получается при делении-на-ноль где один из операторов (но не оба!) является отрицательным.</p>\n<p>JS использует вещественное представление чисел (IEEE 754 числа с плавающей точкой, о котором было рассказано ранее), вразрез с чистой математикой, похоже что <em>есть</em> возможность переполнения при выполнении таких операций как сложение или вычитание, и в этом случае результатом будет <code>Infinity</code> или <code>-Infinity</code>.</p>\n<p>Например:</p>\n<pre><code class=\"language-js\">var a = Number.MAX_VALUE;   // 1.7976931348623157e+308\na + a;                      // Infinity\na + Math.pow( 2, 970 );     // Infinity\na + Math.pow( 2, 969 );     // 1.7976931348623157e+308\n</code></pre>\n<p>Согласно спецификации, если, в результате операции вроде сложения, получается число, превышающее максимальное число, которое может быть представлено, функция IEEE 754 \"округления-до-ближайшего\" определит, каким должен быть результат. Итак, если проще, <code>Number.MAX_VALUE + Math.pow( 2, 969 )</code> ближе к <code>Number.MAX_VALUE</code> чем к бесконечности <code>Infinity</code>, так что его \"округляем вниз,\" тогда как <code>Number.MAX_VALUE + Math.pow( 2, 970 )</code> ближе к бесконечности <code>Infinity</code>, поэтому его \"округляем вверх\".</p>\n<p>Если слишком много об этом думать, то у вас так скоро голова заболит. Не нужно. Серьезно, перестаньте!</p>\n<p>Если однажды вы перешагнете одну из <em>бесконечностей</em>, в любом случае, назад пути уже не будет. Другими словами, в почти литературной форме, вы можете прийти из действительности в бесконечность, но не из бесконечности в действительность.</p>\n<p>Это фактически философский вопрос: \"Что если бесконечность разделить на бесконечность\". Наш наивный мозг скажет что-нибудь вроде \"1\", или, может, \"бесконечность.\" Но ни то, ни другое, не будет верным. И в математике, и в JavaScript, операция <code>Infinity / Infinity</code> не определена. В JS, результатом будет <code>NaN</code>.</p>\n<p>Но, что если любое вещественное положительное число <code>number</code>, разделить на бесконечность <code>Infinity</code>? Это легко! <code>0</code>. А что если вещественное отрицательное число <code>number</code>, разделить на бесконечность <code>Infinity</code>? Об этом в следующей серии, продолжайте читать!</p>\n<h4>Нули</h4>\n<p>Это может смутить математически-думающего читателя, но в JavaScript есть два значения <code>0</code> нормальный ноль (также известных как положительный ноль <code>+0</code>) <em>и</em> отрицательный ноль <code>-0</code>. Прежде чем объяснять почему существует <code>-0</code> , мы должны посмотреть как это работает в JS, потому что это может сбить с толку.</p>\n<p>Кроме того что значение <code>-0</code> может быть буквально присвоено, отрицательный ноль может быть результатом математических операций. Например:</p>\n<pre><code class=\"language-js\">var a = 0 / -3; // -0\nvar b = 0 * -3; // -0\n</code></pre>\n<p>Отрицательный ноль не может быть получен в результате сложения или вычитания.</p>\n<p>Отрицательный ноль при выводе в консоль разработчика обычно покажет <code>-0</code>, хотя до недавнего времени это не было общепринятым, вы можете узнать что некоторые старые браузеры до сих пор выводят <code>0</code>.</p>\n<p>Как бы там ни было, при попытке преобразования отрицательного нуля в строку, всегда будет выведено <code>\"0\"</code>, согласно спецификации.</p>\n<pre><code class=\"language-js\">var a = 0 / -3;\n\n// (некоторые браузеры) выводят в консоль правильное значение\na;                          // -0\n\n// но спецификация лжет вам на каждом шагу!\na.toString();               // \"0\"\na + \"\";                     // \"0\"\nString( a );                // \"0\"\n\n// странно, даже JSON введен в заблуждение\nJSON.stringify( a );        // \"0\"\n</code></pre>\n<p>Интересно,что обратная операция (преобразование из строки <code>string</code> в число <code>number</code>) не врет:</p>\n<pre><code class=\"language-js\">+\"-0\";              // -0\nNumber( \"-0\" );     // -0\nJSON.parse( \"-0\" ); // -0\n</code></pre>\n<p><strong>Предупреждение:</strong> Поведение <code>JSON.stringify( -0 )</code> по отношению к <code>\"0\"</code> странное лишь частично, если вы заметите то обратная операция: <code>JSON.parse( \"-0\" )</code> выведет <code>-0</code> как вы и ожидаете.</p>\n<p>В дополнение к тому что преобразование в строку скрывает реальное значение отрицательного нуля, операторы сравнения также (намеренно) настроены <em>лгать</em>.</p>\n<pre><code class=\"language-js\">var a = 0;\nvar b = 0 / -3;\n\na == b;     // true\n-0 == 0;    // true\n\na === b;    // true\n-0 === 0;   // true\n\n0 > -0;     // false\na > b;      // false\n</code></pre>\n<p>Очевидно, если вы хотите различать <code>-0</code> от <code>0</code> в вашем коде, вы не можете просто полагаться на то,что выведет консоль разработчика, так что придется поступить немного хитрее:</p>\n<pre><code class=\"language-js\">function isNegZero(n) {\n    n = Number( n );\n    return (n === 0) &#x26;&#x26; (1 / n === -Infinity);\n}\n\nisNegZero( -0 );        // true\nisNegZero( 0 / -3 );    // true\nisNegZero( 0 );         // false\n</code></pre>\n<p>Итак, зачем нам нужен отрицательный ноль, вместо обычного значения?</p>\n<p>Есть определенные случаи где разработчики используют величину значения для определения одних данных (например скорость перемещения анимации в кадре) а знак этого числа <code>number</code> для представления других данных (например направление перемещения).</p>\n<p>В этих случаях, как в примере выше, если переменная достигнет нуля и потеряет знак, тогда, вы потеряете информацию о том, откуда она пришла, до того как достигла нулевого значения. Сохранение знака нуля предупреждает потерю этой информации.</p>\n<h3>Специальное равенство</h3>\n<p>Как мы увидели выше, значения <code>NaN</code> и <code>-0</code> ведут себя по--особенному при попытке проверки на равенство. <code>NaN</code> никогда не равно самому себе, так что вы должны использовать метод ES6 <code>Number.isNaN(..)</code> (или полифилл). Аналогично, <code>-0</code> обманывает и притворяется (даже при использовании <code>===</code> строгого равенства -- подробнее в Главе 4) обычным положительным <code>0</code>, так что приходится использовать что-то вроде хаков типа <code>isNegZero(..)</code> как предлогалось выше.</p>\n<p>Для ES6, есть новый метод для проверки двух значений на абсолютное равенство, без всех этих исключений. Он называется <code>Object.is(..)</code>:</p>\n<pre><code class=\"language-js\">var a = 2 / \"foo\";\nvar b = -3 * 0;\n\nObject.is( a, NaN );    // true\nObject.is( b, -0 );     // true\n\nObject.is( b, 0 );      // false\n</code></pre>\n<p>Есть достаточно простой полифилл для <code>Object.is(..)</code> если ES6 не поддерживается:</p>\n<pre><code class=\"language-js\">if (!Object.is) {\n    Object.is = function(v1, v2) {\n        // проверка на `-0`\n        if (v1 === 0 &#x26;&#x26; v2 === 0) {\n            return 1 / v1 === 1 / v2;\n        }\n        // проверка на `NaN`\n        if (v1 !== v1) {\n            return v2 !== v2;\n        }\n        // любые другие значения\n        return v1 === v2;\n    };\n}\n</code></pre>\n<p><code>Object.is(..)</code>, возможно, не должен быть использован в случаях, когда известно что <code>==</code> или <code>===</code> являются <em>безопасными</em> (подробнее в Главе 4 \"Преобразование\"), как операторы, они, вероятно, более эффективны и просты в применении. <code>Object.is(..)</code> по большей части применяется в специальных случаях проверки на равенство.</p>\n<h2>Значение против Ссылки</h2>\n<p>Какт во многих других языках, значения могут быть присвоены/переданы либо с помощью копирования-по-значению,либо с помощью копирования-по-ссылке oв зависимости от синтаксиса, который вы используете.</p>\n<p>Например, в C++ если вы хотите передать число <code>number</code> переменной в функции и иметь обновленное значение переменной, вы можете объявить параметр функции например <code>int&#x26; myNum</code>, и когда вы передадите ему переменную например <code>x</code>, <code>myNum</code> будет <strong>ссылаться на <code>x</code></strong>; ссылки -- это как особые формы указателей, когда вы получаете указатель на другую переменную (как <em>алиас (псевдоним)</em>). Если вы не объявляете ссылочный параметр, переданное значение  <em>всегда</em> будет скопировано, Даэе если это сложный объект.</p>\n<p>В JavaScript, нет указателей, и ссылки работают немного по-другому. вы не можете получить ссылку от одной JS переменной на другую. Это просто невозможно.</p>\n<p>ССылки в JS указывают на (общее) <strong>значение</strong>, так если у вас есть 10 разных ссылок, они всегда будут разными ссылками на одно общее значение; <strong>ни одна из этих ссылок/указателей tне будет указывать друг на друга.</strong></p>\n<p>Более того, в JavaScript, нет никахих синтаксических подсказок которые контролируют как будет происходить присовение/передача по значению или по ссылке. Вместо этого, <em>тип</em> значения <em>полностью</em> контролирует будет ли это значение присвоено с помощью копирования-по-значению,либо с помощью копирования-по-ссылке.</p>\n<p>Давайте продемонстрируем:</p>\n<pre><code class=\"language-js\">var a = 2;\nvar b = a; // `b` всегда копирует значение из `a`\nb++;\na; // 2\nb; // 3\n\nvar c = [1,2,3];\nvar d = c; // `d` это ссылка на общее значение `[1,2,3]`\nd.push( 4 );\nc; // [1,2,3,4]\nd; // [1,2,3,4]\n</code></pre>\n<p>Простые значения (примитивы) <em>всегда</em> назаначаются/передаются копированием-по-значению: <code>null</code>, <code>undefined</code>, <code>string</code>, <code>number</code>, <code>boolean</code>,и ES6 <code>symbol</code>.</p>\n<p>Сложные значения -- объекты <code>object</code> (включая массивы <code>array</code>, и все объекты-обертки -- подробнее в Главе 3) и функции <code>function</code> -- <em>всегда</em> всегда делают копию по ссылке при назначении или передаче.</p>\n<p>В примере выше, т.к. <code>2</code> это примитив, <code>a</code> содержит начальную копию этого значения, а переменной <code>b</code> присвоена другая <em>копия</em> значения. При изменении <code>b</code>, вы никоим образом не меняете значение в переменной <code>a</code>.</p>\n<p>Но <strong>оба<code>c</code> и <code>d</code></strong> отдельные ссылки на одно общее значение <code>[1,2,3]</code>, которое является сложным значением. Важно понимать что никто из переменных: ни <code>c</code> ни  <code>d</code> не \"обладает\" значением <code>[1,2,3]</code> в большей степени -- они оба всего лишь равноправные ссылки на значение. Таким образом, когда мы используем любую ссылку для изменения (<code>.push(4)</code>) актуального общего значения <code>array</code> самого по себе, это влияет только на это общее значение, и обе ссылки будут указываьб на новое измененное значение <code>[1,2,3,4]</code>.</p>\n<p>Раз уж ссылки указывают на сами значения, а не на переменные, вы не можете использовать одну ссылку, чтобы изменить место, куда будет указывать другая ссылка:</p>\n<pre><code class=\"language-js\">var a = [1,2,3];\nvar b = a;\na; // [1,2,3]\nb; // [1,2,3]\n\n// позже\nb = [4,5,6];\na; // [1,2,3]\nb; // [4,5,6]\n</code></pre>\n<p>Когда мы делаем присвоение <code>b = [4,5,6]</code>, мы не делаем абсолютно ничего,что могло бы повлиять на то, <em>куда</em> <code>a</code> все еще ссылается (<code>[1,2,3]</code>). Чтобы это выполнить, <code>b</code>  должно указывать на <code>a</code> вместо того,чтобы ссылаться на массив <code>array</code> -- но такой возможности в JS нет!</p>\n<p>Самым распространненым случаем при котором может возникнуть путаница, является использование параметров функции:</p>\n<pre><code class=\"language-js\">function foo(x) {\n    x.push( 4 );\n    x; // [1,2,3,4]\n\n    // позже\n    x = [4,5,6];\n    x.push( 7 );\n    x; // [4,5,6,7]\n}\n\nvar a = [1,2,3];\n\nfoo( a );\n\na; // [1,2,3,4]  а не  [4,5,6,7]\n</code></pre>\n<p>Когда мы передаем в аргументе переменную <code>a</code>, функция принимает копию <code>a</code> по ссылке для <code>x</code>. <code>x</code> и <code>a</code> разные ссылки на одно общее значение <code>[1,2,3]</code>. Теперь, внутри функции, мы можем использовать ссылку для изменения самого значения (<code>push(4)</code>). Но, когда мы делаем присвоение <code>x = [4,5,6]</code>, мы никак не влияем на то значение, на которое изначально указывала переменная <code>a</code> -- значит, она все еще указывает на (теперь измененное) значение <code>[1,2,3,4]</code>.</p>\n<p>Нельзя с помощью ссылки <code>x</code> изменить место, куда ссылается <code>a</code>. Мы можем лишь изменить содержимое общего значения, на которое указывют <code>a</code> и <code>x</code>.</p>\n<p>Чтобы добиться изменения содержимого переменной <code>a</code> на значение <code>[4,5,6,7]</code>, вы не можете создать и назначить новый массив <code>array</code> -- вы должны изменить существующее значение массива <code>array</code>:</p>\n<pre><code class=\"language-js\">function foo(x) {\n    x.push( 4 );\n    x; // [1,2,3,4]\n\n    // позже\n    x.length = 0; // обнуляем массив по месту\n    x.push( 4, 5, 6, 7 );\n    x; // [4,5,6,7]\n}\n\nvar a = [1,2,3];\n\nfoo( a );\n\na; // [4,5,6,7]  а не  [1,2,3,4]\n</code></pre>\n<p>Как вы можете видеть, <code>x.length = 0</code> и <code>x.push(4,5,6,7)</code> не создавали но массив <code>array</code>, а изменяли существующий общий массив <code>array</code>. Таким образом, конечно, <code>a</code> ссылается на новое значение <code>[4,5,6,7]</code>.</p>\n<p>Помните: вы не можете напрямую управлять/переопределять тип копирования: по-значению или по-ссылке -- эти правила полностью контролируются типом основного значения.</p>\n<p>Чтобы эффективно передать сложное значение (например массив<code>array</code>) с помощью копирования по-значению, вам понадобится вручную создать его копию, так чтобы переданная ссылка больше не указывала на оригинал. Например:</p>\n<pre><code class=\"language-js\">foo( a.slice() );\n</code></pre>\n<p><code>slice(..)</code> без параметров по умолчанию делает полностью новую (поверхностую) копию массива <code>array</code>. Таким образом, мы передаем ссылку только на скопированный массив <code>array</code>, а значит <code>foo(..)</code> не может повлиять на содержимое <code>a</code>.</p>\n<p>Чтобы выполнить обратное действие -- передать примитивное значение таким способом, что его изменения будут, навроде как ссылка -- вам понадобится обернуть значение в другое сложное значение (<code>object</code>, <code>array</code>, и т.п.), которое <em>может</em> быть передано копированием по-ссылке:</p>\n<pre><code class=\"language-js\">function foo(wrapper) {\n    wrapper.a = 42;\n}\n\nvar obj = {\n    a: 2\n};\n\nfoo( obj );\n\nobj.a; // 42\n</code></pre>\n<p>Здесь, <code>obj</code> действует как обертка для примитивного значения в свойстве <code>a</code>. когда мы передаем <code>foo(..)</code>, копия объекта <code>obj</code> передана по ссылке и назначена параметру <code>wrapper</code>. Теперь мы можем использовать ссылку <code>wrapper</code> для доступа к общему объекту, и обновить его свойство. После выполнения функции, при запросе <code>obj.a</code> будет выведено обновленое значение <code>42</code>.</p>\n<p>Если вы захотите передать ссылку на примитивное значение например <code>2</code>, вы можете просто обернуть его в объект-обертку <code>Number</code> (подробнее в Главе 3).</p>\n<p>Это <em>является</em> настоящим копированием по-ссылке для объекта <code>Number</code>, который <em>будет</em> передан функции, но, к несчастью, получение ссылки на общий объект не дает права на изменение общего примитивного значения, как ожидалось:</p>\n<pre><code class=\"language-js\">function foo(x) {\n    x = x + 1;\n    x; // 3\n}\n\nvar a = 2;\nvar b = new Number( a ); // эквивалентно `Object(a)`\n\nfoo( b );\nconsole.log( b ); // 2, не 3\n</code></pre>\n<p>Проблема в том, что лежащее в основе примитивное значение <em>неизменно</em> (то же самое справедливо для <code>String</code> и <code>Boolean</code>). Если объект <code>Number</code> содержит примитивное значение <code>2</code>, это означает, что объект <code>Number</code> не может быть изменен для хранения другого значения; вы можете лишь создать новый объект <code>Number</code> с другим значением.</p>\n<p>Когда <code>x</code> использовано в выражении <code>x + 1</code>, лежащее в основе примитивное значение <code>2</code> распаковано (извлечено) из объекта <code>Number</code> автоматически, значит строка <code>x = x + 1</code> очень незаметно меняет <code>x</code> и вместо ссылки на общий объект <code>Number</code>, переменная <code>x</code> просто содержит примитивное значение <code>3</code> являющееся результатом математического действия <code>2 + 1</code>. Таким образом, <code>b</code> снаружи все еще ссылается на оригинальный неизмененный/неизменный объект <code>Number</code> содержащий значение <code>2</code>.</p>\n<p>Вы <em>можете</em> добавить свойство поверх объекта <code>Number</code> (не изменяя его примитивного значения), так вы сможете обменимваться информацией косвенно через дополнительные свойства.</p>\n<p>В любом случае, это не является общепринятым; и, возможно, большинство разработчиков не считают это хорошей практикой.</p>\n<p>Вместо использования объекта-обертки <code>Number</code> таким способом, возможно, гораздо удобнее использовать обычный, созданный вручную, объект (<code>obj</code>), о котором говорилось в примере ранее. Никто не говорит, что нет разумного использования объекта-обертки <code>Number</code> -- просто возможно предпочтительнее будет использовать примитивное значение в большинстве случаев.</p>\n<p>Ссылки достаточно мощные, но иногда они есть там где вам нужно, а иногда они нужны вам там, где их нет. Единственное влияние которое у вас есть при выборе типа копирования по-ссылке или по-значению это выбор типа самого значения, так что вы должны косвенно влиять на поведение присвоения/передачи путем выбора типа значений.</p>\n<h2>Обзор</h2>\n<p>В JavaScript, массивы <code>array</code> -- простые коллекции значений любого типа с пронумерованными ячейками. Строки <code>string</code> что-то \"подобное массивам <code>array</code>\", но у них есть различия в поведении и нужно быть осторожными при использовании строк как массивов <code>array</code>. Числа в JavaScript включают в себя как \"целые\" значения так и значения с плавющей точкой.</p>\n<p>Среди примитивнх значений есть некоторые специальные значения.</p>\n<p>Тип <code>null</code> имеет только одно значение: <code>null</code>, также как и тип <code>undefined</code> имеет только одно значение -- <code>undefined</code>. <code>undefined</code> -- изначальное стандартное значение в любой переменной или свойстве, если никакое другое значение не представлено. Оператор <code>void</code> позволяет вам получить значение <code>undefined</code> от любого другого значения.</p>\n<p>Числа <code>number</code> включают в себя несколько специальных значений, например <code>NaN</code> (по идее \"Не-Число\", но на самом деле более предпочтительно \"неправильное число\"); бесконечности <code>+Infinity</code> и <code>-Infinity</code>; и <code>-0</code>.</p>\n<p>Простые примитивные изначения (строки <code>string</code>, числа <code>number</code>, и т.п.) назначаются/передаются копированием по-значению, но сложные значения (объекты <code>object</code>, и т.п.) назначаются/передаются копированием по-ссылке. Ссылки в JS не такие как ссылки/указатели в других языках -- они никогда не указывают на другие переменные/ссылки, только на сами значения.</p>","frontmatter":{"title":"Вы не знаете JS. Типы и грамматика. Глава 2. Типы."}}},"pageContext":{"slug":"/2018-11-1-You-dont-know-JS-Types/"}}