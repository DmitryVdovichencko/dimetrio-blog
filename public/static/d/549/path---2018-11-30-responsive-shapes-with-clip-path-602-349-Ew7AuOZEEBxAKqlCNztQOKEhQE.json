{"data":{"markdownRemark":{"html":"<p>Перевод статьи <a href=\"https://www.smashingmagazine.com/2015/05/creating-responsive-shapes-with-clip-path/\">Creating Responsive Shapes With Clip-Path And Breaking Out Of The Box</a></p>\n<p>Свойство CSS <code>clip-path</code> -- ваш билет к изменению формы монотонных, боксовых разметок традиционно ассоциирующимся с простым, отзывчивым дизайном. Вы начнете мыслить нестандартно, буквально выходить за рамки, и шестиугольники, звезды и восьмиугольники начнут оживать на ваших веб страницах. Однажды попробовав <code>clip-path</code>, вы будете постоянно генерировать любые фигуры, просто настраивая несколько значений</p>\n<p>Несмотря на то что основным объектом этой статьи является использование <code>clip-path</code> для создания многоугольников с помощью CSS, все примеры поддерживают инлайновый  SVG, для дополнительной поддержки в Firefox. Создание отзывчивых фигур с помощью SVG  -- простая задача, если вы хоть раз использовали <code>CSS clip-path</code>.</p>\n<h2>Clip-Path, в общих чертах</h2>\n<p>Вырезать фигуры, свойством <code>clip-path</code>, сродни вырезанию фигур (таких как  круг или пятиугольник) из прямоугольного куска бумаги. Это свойство находится в спецификации “CSS Masking Module Level 1”. Состояние спецификации, “CSS masking поддерживает два значения  для частичного или полного скрытия частей визуальных элементов: маскирование и обрезка”.</p>\n<p>Первая часть, т.е. маскирование, использует графический элемент, такие как изображение PNG, CSS градиент или SVG элемент, как маску для скрытия частей другого элемента.</p>\n<p>Вторая часть, т.е. <code>clip-path</code>, задействует замкнутый контур, который может быть базовой фигурой определенной в CSS или SVG используя тэг clipPath. Область внутри контура отобразится, а все что снаружи будет отсечено.</p>\n<p>Примечание: Маскирование выходит за пределы этой статьи, но на CSS-Tricks и HTML5 Rocks можно найти более подробную информацию.\nНиже простая визуализация работы <code>clip-path</code>:</p>\n<p data-height=\"400\" data-theme-id=\"0\" data-slug-hash=\"KpdomO\" data-default-tab=\"html,result\" data-user=\"imohkay\" data-pen-title=\"Visualizing clip-path\" class=\"codepen\">See the Pen <a href=\"https://codepen.io/imohkay/pen/KpdomO/\">Visualizing clip-path</a> by Karen Menezes (<a href=\"https://codepen.io/imohkay\">@imohkay</a>) on <a href=\"https://codepen.io\">CodePen</a>.</p>\n<script async src=\"https://static.codepen.io/assets/embed/ei.js\"></script>\n<p>Примечание: примеры из этой статьи, включая указанный выше, будут работать в Firefox а также в WebKit и Blink браузерах, включая Chrome, Safari и Opera.</p>\n<h2>Clip-Path это вам не Clip</h2>\n<p>Есть такое старое CSS 2.1 свойство <code>clip</code>, которое весьма ограничено, главным образом потому, что оно поддерживает только прямоугольную форму. Это свойство устарело, вместо него нужно использовать clip-path.</p>\n<p>Пример использования устаревшего синтаксиса:</p>\n<pre><code class=\"language-css\">.element {\n  clip: rect(30px, 30px, 20px, 20px);\n}\n</code></pre>\n<h2>Поддержка Clip-Path</h2>\n<p>В августе 2014, спецификация “CSS Masking Module” была опубликована как “Candidate Recommendation,” это шаг вперед по сравнению с ранним черновиком “Last Call Working Draft”. До того как мы посмотрим на поддержку в браузерах, важно рассмотреть разные способы применения clip-path к элементу, beпотому что поддержка в бразуерах вариьируется в зависимости от этих способов.</p>\n<p>Есть два способа применения clip-path:</p>\n<ol>\n<li>\n<p>Базовые фигуры CSS из “CSS Shapes Module” предоставляют удобный способ использования clip-path. Доступны следующие варианты фигур: polygon, circle, ellipse и inset; inset для прямоугольных фигур.</p>\n</li>\n<li>\n<p>С помощью SVG можно, в качестве альтернативы, создать фигуру используя SVG и затем обрезать элемент по этой фигуре используя синтакс URL. Есть два способа реализации:</p>\n</li>\n<li>\n<p>ссылкой на инлайновый SVG (т.е. SVG разметка будет размещена прямо на странице),</p>\n</li>\n<li>\n<p>ссылкой на внешний SVG документ. В обоих случаях, элемент clipPath внутри SVG используется чтобы обернуть элемент который определяет фигуру обрезки, будь то круг, многоугольник, или дркгой элемент. Сравните демо ниже в Firefox и в WebKit или Blink браузере например Chrome чтобы почувствовать разницу. Квадратные изображения означают ошибку при поддержке браузером. Примечание: третье изображение не показывается в Safari. Несмотря на широкий дебаггинг, решить проблему не удалось. Я была бы благодарна, если в секции комментов встретится решение.</p>\n</li>\n</ol>\n<p data-height=\"500\" data-theme-id=\"0\" data-slug-hash=\"GJpxXY\" data-default-tab=\"html,result\" data-user=\"imohkay\" data-pen-title=\"Clip-path: Browser support\" class=\"codepen\">See the Pen <a href=\"https://codepen.io/imohkay/pen/GJpxXY/\">Clip-path: Browser support</a> by Karen Menezes (<a href=\"https://codepen.io/imohkay\">@imohkay</a>) on <a href=\"https://codepen.io\">CodePen</a>.</p>\n<script async src=\"https://static.codepen.io/assets/embed/ei.js\"></script>\n<p>Если вы тестировали пример кода выше в разных браузерах, то наверняка заметили, что поддержка клиппирования довольно странная, и на данный момент она основывается на выборе способов которые вы применяете чтобы обрезать элемент:</p>\n<ul>\n<li>\n<p>с CSS: Chrome 24+, Safari 7+, Opera 15+, iOS 7.1+, Android 4.4+, Opera Mobile 24+ (Примечание: для поддержки в указанных браузерах необходимо использовать вендорные префиксы -webkit.)</p>\n</li>\n<li>\n<p>с SVG: все браузеры указанные выше и Firefox 3.5+</p>\n</li>\n</ul>\n<p>Свойство clip-path пока не поддерживается Internet Explorer, но находится на рассмотрении как часть “Masking Module.”</p>\n<p>Примечание: Есть оговорка насчет поддержки SVG для клиппирования. Современные WebKit и Blink браузеры иподдерживают клиппирование с SVG только если SVG -- инлайновый (т.е. внутри документа). Ссылки на внешние SVG поддерживаются только в Firefox, что подтверждается в примере кода выше. Проект Chromium знает об этом баге и работает над ним.</p>\n<p>Давайте посмотрим преимущества CSS и SVG при использовании clip-path.</p>\n<p>Преимущества CSS</p>\n<ul>\n<li>Легкий для понимания простой синтаксис, по причине относительной простоты базовых CSS фигур.</li>\n<li>Отзывчивость легко достигается с помощью применения относительных единиц измерения, таких как проценты.</li>\n</ul>\n<p>Преимущества SVG</p>\n<ul>\n<li>Лучшая поддержка в браузерах, включая Firefox</li>\n<li>Вы можете обрезать сложные фигуры, использовать множество фигур и текст.</li>\n</ul>\n<p>Пока CSS предлагает свойство background-clip которое поддерживает множество вариантов (включая нестандартные способы обрезки текста), ни background-clip ни CSS’ clip-path не достигают того, что можно  сделать с помощью SVG обрезки в современных браузерах. Знакомство с clip-path через CSS, тем не менее, не такое пугающее (особенно если вы не знакомы с манипуляциями SVG) и подготовит вас к тонкостям клиппирования с SVG, также как в “CSS Shapes Module,” где содержимое выравнивается по форме элемента.</p>\n<p>Примечание: если вам не терпится окунуться во всет тонкости SVG, <a href=\"https://www.sarasoueidan.com/blog/css-svg-clipping/\">обзор Sara Soueidan</a> будет хорошим началом.</p>\n<p>Давайте посмотрим на плюсы и минусы clip-path чтобы постепенно улучшить наш дизайн.</p>\n<p>Плюсы</p>\n<ul>\n<li>Браузеры, не поддерживающие свойство clip-path будут его игнорировать. Если вы используете его с осторожностью, пользователи неподдерживаемых браузеров ничего не заподозрят. </li>\n<li>Как только фигура обрезки сгенерирована, спецификация утверждает, что указатель события не будет направлен на область вне области обрезки (что идеально).\nТаким образом событие клика ограничено фигурой и ее внешними границами. Мы увидим это в примерах кода ниже. </li>\n<li>Вы можете использовать проценты или любые другие единицы длины такие как px или em, для определения координат с базовыми фигурами CSS. Относительные единицы такие как проценты могут быть использованы для создания отзывчивых фигур, идеальных для адаптивного дизайна.</li>\n</ul>\n<p>Минусы</p>\n<ul>\n<li>Все границы, тени и контуры снаружи области обрезки будут отсечены. Вы можете добавить границу и ожидать что это будет выполнено. Посмотрим на некоторые альтернативы ниже. </li>\n<li>Спецификация еще не достигла стадии \"Recommendation\", так что всегда есть шанс, что синтаксис будет временно изменен.</li>\n<li>Сообщалось о нескольких багах при использовании clip-path и 3Д трансформаций, переходов и проразчности, они будут рассмотрены в примерах далее. Будьте осторожны и избегайте комбинировая свойств, которые могут спровоцировть эти проблемы.</li>\n</ul>\n<h2>Clip-Path с использованием polygon: использование и синтаксис</h2>\n<p>Примеры кода ниже сфокусированы на использовании многоугольников в дизайне. Синтаксис для базовых фигур (т.е. прямоугольник, круг и эллипс) достаточно прост, и вы можете сделать с ними достаточно много. Многоугольники, тем не менее, практически открывают дверь к бесконечному числу фигур.</p>\n<p>Базовый синтаксис для многоугольника выглядит следующим образом:</p>\n<pre><code class=\"language-css\">.element { clip-path: polygon(x1 y1, x2 y2, x3 y3, ...); }\n</code></pre>\n<p>Каждая пара аргументов в списке представляет координаты по осям <code>x</code> и <code>y</code> вершин многоугольника.</p>\n<p>Вот как это выглядит в реальном мире (не считая текущей поддержки версии с префиксом WebKit):</p>\n<pre><code class=\"language-css\">.element { clip-path: polygon(0 100%, 0 0, 100% 0, 80% 100%); }\n</code></pre>\n<p>Добавим поддержку для Firefox с помощью ссылки на инлайновый SVG:</p>\n<pre><code class=\"language-css\">.element { clip-path: url(\"#clip-shape\"); }\n</code></pre>\n<p>Вот как выглядит наш селектор с кроссбраузерной поддержкой:</p>\n<pre><code class=\"language-css\">.element {\n  -webkit-clip-path: polygon(0 100%, 0 0, 100% 0, 80% 100%);\n  clip-path: polygon(0 100%, 0 0, 100% 0, 80% 100%);\n  -webkit-clip-path: url(\"#clip-shape\"); /* required for Webkit/Blink browsers if you're using only inline SVG clipping paths, but not CSS clip-path */\n  clip-path: url(\"#clip-shape\");\n}\n</code></pre>\n<p>Ниже представлен код инлайнового SVG, который необходимо добавить в разметку.</p>\n<pre><code class=\"language-html\">&#x3C;svg width=\"0\" height=\"0\">\n  &#x3C;defs>\n    &#x3C;clipPath id=\"clip-shape\" clipPathUnits=\"objectBoundingBox\">\n      &#x3C;polygon points=\"0 1, 0 0, 1 0, 0.8 1\" />\n    &#x3C;/clipPath>\n  &#x3C;/defs>\n&#x3C;/svg>\n</code></pre>\n<p>И окончательный пример кода с многоугольником:</p>\n<p data-height=\"404\" data-theme-id=\"0\" data-slug-hash=\"pJjVob\" data-default-tab=\"html,result\" data-user=\"imohkay\" data-pen-title=\"Clip-path: Demo\" class=\"codepen\">See the Pen <a href=\"https://codepen.io/imohkay/pen/pJjVob/\">Clip-path: Demo</a> by Karen Menezes (<a href=\"https://codepen.io/imohkay\">@imohkay</a>) on <a href=\"https://codepen.io\">CodePen</a>.</p>\n<script async src=\"https://static.codepen.io/assets/embed/ei.js\"></script>\n<p>Вы можете создать отзывчивый SVG для обрезки в следующем порядке:</p>\n<ul>\n<li>Установите width и height для SVG в 0.</li>\n<li>Назначьте ID для clipPath элемента внутри SVG, на который можно ссылаться в CSS. Вы можете использовать инлайновый или внешний SVG, держа в уме поддержку браузеров, о которой говорилось ранее.</li>\n<li>Испольуйте значения координат в процентах назначенные в CSS clip-path. Просто делите их на 100 и уберите единицы измерения SVG.\nУстановите значения атрибута clipPathUnits для objectBoundingBox, таким образом фигура обрезки послужит границами HTML элемента на который она ссылается.</li>\n</ul>\n<p><a href=\"http://demosthenes.info/blog/1007/Combining-CSS-clip-path-and-Shapes-for-New-Layout-Possibilities\">Dudley Storey</a> может рассказать больше об этом.</p>\n<p>Давайте посмотрим на примере как составить координаты для многоугольника.</p>\n<p>Итак у нас есть изображение, которое обрезано. Фоновым цветом обозначены габариты оригинального изображения. Ячейки с координатами просто абсолютно спозиционированные дивы, положение которых, соответствует координатам многоугольника в процентах. Вы увидите, что они сохраняют свою позицию, даже даже если вы измените ширину окна браузера (например, до 400px или более).</p>\n<p data-height=\"459\" data-theme-id=\"0\" data-slug-hash=\"pJjVgE\" data-default-tab=\"css,result\" data-user=\"imohkay\" data-pen-title=\"Clip-path: Polygon coordinates\" class=\"codepen\">See the Pen <a href=\"https://codepen.io/imohkay/pen/pJjVgE/\">Clip-path: Polygon coordinates</a> by Karen Menezes (<a href=\"https://codepen.io/imohkay\">@imohkay</a>) on <a href=\"https://codepen.io\">CodePen</a>.</p>\n<script async src=\"https://static.codepen.io/assets/embed/ei.js\"></script>\n<h2>Реальные примеры использования Clip-Path</h2>\n<p>Примечание: Каждый пример кода в этой статье использует clip-path с CSS но также имеет инлайновый SVG в разметке с классом clip-svg, который просто обнуляет значения высоты и ширины SVG. В качестве альтернативы, вы можете удалить класс и обнулить высоту и ширину прямо в разметке SVG.</p>\n<p>Пример 1: Обрезаем изображение до разных многоугольных фигур</p>\n<p>В данном случае нам понадобится определение многоугольника, это плоская замкнутая фигура состоящая из прямых линий.</p>\n<p>Таким образом, фигура не может быть многоугольником если содержит кривые, разомкнута, или состоит менее чем из трех отрезков. Самые часто встречающиеся многоугольники: треугольники, четырехугольники, пятиугольники и шестиугольники. Даже фигура звезды является многоугольником, т.к. границы многоугольника связаны между собой.</p>\n<p>Примечание: Изображения в примерах -- отзывчивые. Используя  решение для отзывчивости изображений img { max-width: 100%; height: auto; } и адаптивные области обрезки для CSS и SVG, мы делаем наши многоугольники пропорционально уменьшающимися и увеличивающимися.</p>\n<p>Этот пример является результатом упражнений по назначению координат для многоугольных фигур. В примере добавлены несколько фигур, которые вы можете использовать для своего дизайна. При наведении курсора на каждое изображение, вы увидите соотношение сторон оригинального изображения.</p>\n<p>Ничто не сравнится с особенным [Clippy] (<a href=\"http://bennettfeely.com/clippy\">http://bennettfeely.com/clippy</a>), GUI инструментом от Bennett Feely для визуализации фигур. Все координаты для всех существующих фигур указаны в процентах, а также есть вариант с настраиваемым многоугольником. Это поворотный момент. Вы можете использовать Clippy для создания фигур обрезки и SVG для них, с целью лучшей поддержки в браузерах.</p>\n<p data-height=\"461\" data-theme-id=\"0\" data-slug-hash=\"RPWyjz\" data-default-tab=\"html,result\" data-user=\"imohkay\" data-pen-title=\"Clip-path: Polygon shapes\" class=\"codepen\">See the Pen <a href=\"https://codepen.io/imohkay/pen/RPWyjz/\">Clip-path: Polygon shapes</a> by Karen Menezes (<a href=\"https://codepen.io/imohkay\">@imohkay</a>) on <a href=\"https://codepen.io\">CodePen</a>.</p>\n<script async src=\"https://static.codepen.io/assets/embed/ei.js\"></script>\n<p>Пример 2: Анимация базовых фигур с помощью переходов CSS </p>\n<p>Наведите курсор на фиолетовый шестиугольник. Он трансформируется в восьмиугольник. Тем не менее, переход CSS не сработал.</p>\n<p>Причина такого поведения объяснена в статье Sara Soueidan об анимации фигур CSS : “Число точек конечной фигуры должно соответствовать числу точек начальной фигуры.” Это вполне разумно!</p>\n<p>Т.к. шестиугольник имеет шесть пар координат вершин, давайте добавим еще две пары дублирующих координат, чтобы достичь числа координат для восьмиугольника. эти дублирующие пары координат никак не повлияют на шестиугольник.</p>\n<p>Так выглядит стандартное объявление шести пар координат для шестиугольника:</p>\n<pre><code class=\"language-css\">clip-path: polygon(50% 0%, 100% 25%, 100% 75%, 50% 100%, 0% 75%, 0% 25%);\n</code></pre>\n<p>А это объявление щестиугольника с восемью парами координат (первые две вершины продублированы):</p>\n<pre><code class=\"language-css\">clip-path: polygon(50% 0%, 50% 0%, 100% 25%, 100% 25%, 100% 75%, 50% 100%, 0% 75%, 0% 25%);\n</code></pre>\n<p>Теперь, при трансформации фигуры, переход будет плавным, как в примере ниже.</p>\n<p>Примечание: Для браузеров поддерживающих области обрезки через SVG (а именно Firefox), нам понадобится добавить SMIL анимацию для реализации перехода при наведении. Согласно SMIL спецификации, анимации могут использоваться для изменения контуров и точек фигур SVG, которое невозможно выполнить средствами CSS.</p>\n<p>Помните что некоторые осуждают использование SMIL в Chrome и Chromium при этом фокусируясь на внедрении Web Animations API, кторое к сожалению пока на стадии раннего черновика.</p>\n<p>В примере ниже (background image courtesy of morgueFile), вы можете увидеть, что мы анимировали вершины многоугольника между событиями указателя мыши mouseover и mouseout events в течение 0.2 секунд. Обратите внимание на тэг <animate> в SVG разметке.</p>\n<p data-height=\"486\" data-theme-id=\"0\" data-slug-hash=\"ZGbjyG\" data-default-tab=\"css,result\" data-user=\"imohkay\" data-pen-title=\"Clip-path: shape transition: Part 2\" class=\"codepen\">See the Pen <a href=\"https://codepen.io/imohkay/pen/ZGbjyG/\">Clip-path: shape transition: Part 2</a> by Karen Menezes (<a href=\"https://codepen.io/imohkay\">@imohkay</a>) on <a href=\"https://codepen.io\">CodePen</a>.</p>\n<p>Пример 3: Добавляем границы для обрезанного объекта.</p>\n<p>Короче, границы, контуры и тени that находящиеся снаружи обрезаемой области будут удалены.</p>\n<p>Меня немного опечалил этот факт, и я решила отправить запрос представителям W3C рабочей группы CSS. Тем не менее, в итоге оказалось, что нет способа реализовать это при использовании базовых фигур. Dirk Schulze ответил на мой запрос: “Да, все операции отрисовки,которые принадлежали элементу будут обрезаны. Это включает контуры и границы.”</p>\n<p>Посмотрите на пример кода ниже. Наведите курсор на ромб с частичными границами чтобы увидеть оригинальную, полную версию со всеми границами.</p>\n<p data-height=\"330\" data-theme-id=\"0\" data-slug-hash=\"zGvLjo\" data-default-tab=\"css,result\" data-user=\"imohkay\" data-pen-title=\"Clip-path: Borders\" class=\"codepen\">See the Pen <a href=\"https://codepen.io/imohkay/pen/zGvLjo/\">Clip-path: Borders</a> by Karen Menezes (<a href=\"https://codepen.io/imohkay\">@imohkay</a>) on <a href=\"https://codepen.io\">CodePen</a>.</p>\n<script async src=\"https://static.codepen.io/assets/embed/ei.js\"></script>\n<p>Конечно, мы всегда можем использовать CSS хак чтобы получить границу, к чему я в итоге и решила прибегнуть — старый добрый генерируемый контент.</p>\n<p>В примере ниже создается копия элемента через псевдо-элемент (content:after) с абсолютным позиционированием. Получается иллюзия границы, позволяя нам использовать интересные эффекты, такие как граница с градиентом во втором восьмиугольнике и добавление тени с помощью CSS фильтра на третьем (не очень симпатично, зато работает). Заметьте, что that CSS фильтры на текущий момент работают только в Firefox и в WebKit и в Blink браузерах.</p>\n<p data-height=\"496\" data-theme-id=\"0\" data-slug-hash=\"MwaBBK\" data-default-tab=\"css,result\" data-user=\"imohkay\" data-pen-title=\"Clip-path: Border simulation\" class=\"codepen\">See the Pen <a href=\"https://codepen.io/imohkay/pen/MwaBBK/\">Clip-path: Border simulation</a> by Karen Menezes (<a href=\"https://codepen.io/imohkay\">@imohkay</a>) on <a href=\"https://codepen.io\">CodePen</a>.</p>\n<p>Пример 4: Используем CLIP-PATH для создания \"бриллиантовой\" сетки из ромбов.</p>\n<p>Ниже изображение которое мы будем использовать.</p>\n<p>{% assign image = page.images[2] %}\n{% include image.html image=image %}</p>\n<p>А это то, к чему мы стремимся. По наведению на один из трех нижних блоков, вы увидите что фоновый цвет постепенно исчезает и появляется фон.</p>\n<p>{% assign image = page.images[3] %}\n{% include image.html image=image %}</p>\n<p>Актуальный размер изображения составляет 600 × 600 пикселей. Значит, давайте начнем с четырех пустых дивов по 300 пикселей каждый и применим к ним одинаковое фоновое изображение. Еще добавим родительский контейнер размером 604 пикселя и разместим изображения с применением свойства <code>inline-block</code>.</p>\n<p>{% assign image = page.images[4] %}\n{% include image.html image=image %}</p>\n<p>Теперь, изменим значение свойства background-position для каждого изображения на <code>top</code>, <code>left</code>, <code>right</code> и <code>bottom</code>, соответственно.</p>\n<p>{% assign image = page.images[5] %}\n{% include image.html image=image %}</p>\n<p>Давайте обрежем каждый блок по фигуре ромба. </p>\n<p>Мы перекроем абсолютно спозиционированным слоем три нижних изображения, с небольшим текстом.</p>\n<p>{% assign image = page.images[6] %}\n{% include image.html image=image %}</p>\n<p>Теперь переместим изображения в строки — второе и третье изображение в одну строку, а первое и четвертое изображение в собственные индивидуальные строки.</p>\n<p>{% assign image = page.images[7] %}\n{% include image.html image=image %}</p>\n<p>Наконец, используем отрицательные <code>margins</code> чтобы поднять вторую и третью строки, таким образом они будут располагатьс я как в примере ниже. мы можем удалить значение ширины родительского контейнера 604 пикселя, и назначить медиа запросы, чтобы блоки ромбов менялись от расположения в колонку на маленьких экранах, до расположения в строку на экранах побольше.</p>\n<p data-height=\"347\" data-theme-id=\"0\" data-slug-hash=\"KpdBrw\" data-default-tab=\"css,result\" data-user=\"imohkay\" data-pen-title=\"Clip-path: Diamond grid\" class=\"codepen\">See the Pen <a href=\"https://codepen.io/imohkay/pen/KpdBrw/\">Clip-path: Diamond grid</a> by Karen Menezes (<a href=\"https://codepen.io/imohkay\">@imohkay</a>) on <a href=\"https://codepen.io\">CodePen</a>.</p>\n<script async src=\"https://static.codepen.io/assets/embed/ei.js\"></script>\n<p>Работая над эти примером, я заметила баг в Chrome с <code>pointer-events</code> направленным вне обрезанной области, что является нарушением спецификации: “По умолчанию, <code>pointer-events</code> не должно ссылаться на отсеченные (неотображаемые) области фигуры.” Я получила ошибку. Проблема в этом примере решена использованием свойства <code>pointer-events</code> со значением <code>none</code> для слоя наложения. В качестве альтернативы, вы можете применить такое же значение <code>clip-path</code> для слоя наложения Чтобы решить проблему.</p>\n<p>Из-за применения отрицательных отступов, этот пример может выглядеть странно в браузерах, не поддерживающих <code>clip-path</code>. Вам нужно использовать что-то типа проверки возможности использования <code>clip-path</code> для применения отступов (хотя, я этого не пробовала) или использовать запрос для CSS @supports, хотя последнее я не рекомендую использовать в продакшене.</p>\n<p>Пример 5: Делаем глупую страничку профиля с шестиугольниками.</p>\n<p>В результате наша страница должна выглядеть так:</p>\n<p>{% assign image = page.images[8] %}\n{% include image.html image=image %}</p>\n<p>Начнем с добавления фонового изображения из шестиугольных плиток для <code>body</code> (спасибо за изображение Subtle Patterns).</p>\n<p>Значения шестиугольника для clip-path могут быть получены из примеров ниже или с помощью Clippy tool.</p>\n<p>Первый шестиугольник использует фоновое изображение (т.к. мы подмешиваем скучный бордовый в фон используя свойство <code>background-blend-mode</code>). Используя полученное содержимое, абсолютно спозиционированный перекрывающий слой обрезается до бордового треугольника, который вы видите внизу. Он исчезает при наведении курсора.</p>\n<p>Второй шестиугольник, со словом “work,” просто содержит серый фон, который меняется при наведении.</p>\n<p>У третьего шестиугольника есть граница с градиентом, так же как и в одном из примеров с созданием границ с помощью <code>clip-path</code>.</p>\n<p>Шестиугольники складываются на маленьких экранах и центрируются по вертикали на экранх побольше. Я использовала комбинацию свойства <code>display</code> : <code>table</code> и хака для абсолютного центрирования — конечно, вы можете использовать <code>flexbox</code>, <code>floats</code> или что-то еще, что поможет удержать ваш корабль верстки \"на плаву\".</p>\n<p>Вот итоговый пример кода.</p>\n<p data-height=\"397\" data-theme-id=\"0\" data-slug-hash=\"ZGbmoQ\" data-default-tab=\"css,result\" data-user=\"imohkay\" data-pen-title=\"Clip-path: Hexagon shapes for dummy profile page\" class=\"codepen\">See the Pen <a href=\"https://codepen.io/imohkay/pen/ZGbmoQ/\">Clip-path: Hexagon shapes for dummy profile page</a> by Karen Menezes (<a href=\"https://codepen.io/imohkay\">@imohkay</a>) on <a href=\"https://codepen.io\">CodePen</a>.</p>\n<p>Я обнаружила баг <code>clip-path</code> при создании этого примера. Изменение значения свойства <code>opacity</code> в сочетаниии с переходами CSS провоцирует мигание и артефакты на странице. Избегайте этого, если вы используете <code>clip-path</code> чтобы улучшить дизайн.</p>\n<p>Также есть проблема при использовании <code>clip-path</code> и свойства <code>backface-visibility</code> если его установить в значение <code>hidden</code>. Этот баг указан в  баг трекере Chromium и мне удалось его воспроизвести используя основной синтаксис для фигур в Chrome на Linux. Помните об этом если используете <code>clip-path</code> фигуру для создания крутого 3D поворота или чего нибудь, что использует 3D трансформации CSS.</p>\n<p>Обрезка с помощью SVG без труда побеждает из-за ее гибкости иnи вариаций, но ничто не сравнится с легкостью,с котрой элемент может быть обрезан спомощью CSS. Фактически, те же координаты для многоугольника могут быть играючи преобразованы для создания отзывчивого SVG  и лучшей поддержки браузерами. С <code>clip-path</code>, вы можете кардинально менять вид и поведение страницы, не слишком волнуясь о поддержке браузерами, где она ухудшена. При выборе <code>clip-path</code> для улучшения дизайна, следите за статусом спецификации, возможно она продвинется до статуса “Recommendation”.</p>\n<p>Ресурсы, Инструменты и Вдохновение</p>\n<ul>\n<li><a href=\"http://www.w3.org/TR/css-masking-1\">“CSS Masking Module Level 1”</a> W3C лучший источник истины при возникновении сомнений.</li>\n<li><a href=\"http://sarasoueidan.com/blog/css-svg-clipping\">“Clipping in CSS and SVG: The clip-path Property and <code>&#x3C;clipPath></code> Element”</a>  Подробное руководство Sara Soueidan по обрезке фигур. Т.к. по большей части там фокусируются на SVG, эта статья -- фантастическое введение, с достаточным количеством информации даже для продвинутых читателей.</li>\n<li><a href=\"http://tympanus.net/codrops/css_reference/clip-path\">“clip-path”</a> статья Sara Soueidan для Codrops -- тщательно проработанное и исчерпывающее руководство разбивает реально сложные модули на то что легко понять и усвоить.</li>\n<li><a href=\"http://css-tricks.com/clipping-masking-css/\">“Clipping and Masking in CSS”</a> статья Chris Coyier на CSS-Tricks снабженная несколькими полезными примерами, объясняющими как клиппирование так и маскирование.</li>\n<li><a href=\"http://bennettfeely.com/clippy\">Clippy</a> инструмент от Bennett Feely для создания clip-path может генерировать множество предустановленных и кастомных многоугольников, кругов и эллипсов для CSS clip-path. Все значения указаны в процентах, следовательно, это будет полезно при создании адаптивной верстки.</li>\n<li><a href=\"http://cssplant.com/clip-path-generator\">Clip Path Generator CSS Plant</a> предоставляет более исчерпывающий графический интерфейс для применения клиппирования или маскирования элементов. Браузерная поддержка реализована для Firefox, Chrome, Safari и старых iOS. Размеры в пикселях, не в процентах.</li>\n<li><a href=\"http://www.species-in-pieces.com/\">Species in Pieces</a> Захватывающая дух, демонстрация из 30 исчезающих видов была разработана полностью с помощью CSS’ clip-path, без помощи <code>canvas</code> или <code>WebGL</code>. Пока остальные браузеры не подхватятся смотрите ее в WebKit или Blink браузерах.</li>\n</ul>","frontmatter":{"title":"Создаем крутые фигуры с помощью Clip-Path и разбиваем привычную боксовую модель."}}},"pageContext":{"slug":"/2018-11-30-Responsive-Shapes-With-Clip-Path/"}}